import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;

public class Pacman extends JPanel implements ActionListener, KeyListener {

    class Block {
        int x, y, width, height;
        Image image;
        int startX, startY;
        char direction = 'U'; // U D L R
        int velocityX = 0;
        int velocityY = 0;
        int collisionPadding = 4; // Padding on all sides

        Block(Image image, int x, int y, int height, int width) {
            this.x = x;
            this.y = y;
            this.height = height;
            this.width = width;
            this.image = image;
            this.startX = x;
            this.startY = y;
        }

        void updateDirection(char direction) {
            char prevDirection = this.direction;
            this.direction = direction;
            updateVelocity();
            this.x += this.velocityX;
            this.y += this.velocityY;

            // Collision check with walls after move
            for (Block wall : walls) {
                if (collision(this, wall)) {
                    this.x -= this.velocityX;
                    this.y -= this.velocityY;
                    this.direction = prevDirection;
                    updateVelocity();
                }
            }
        }

        void updateVelocity() {
            if (this.direction == 'U') {
                this.velocityX = 0;
                this.velocityY = -tileSize / 4;
            } else if (this.direction == 'D') {
                this.velocityX = 0;
                this.velocityY = tileSize / 4;
            } else if (this.direction == 'L') {
                this.velocityY = 0;
                this.velocityX = -tileSize / 4;
            } else if (this.direction == 'R') {
                this.velocityY = 0;
                this.velocityX = tileSize / 4;
            }
        }

        void reset() {
            this.x = this.startX;
            this.y = this.startY;
            this.velocityX = 0;
            this.velocityY = 0;
            this.direction = 'U';
        }
    }

    private int columnCount = 19;
    private int rowCount = 21;
    private int tileSize = 32;
    private int boardWidth = columnCount * tileSize;
    private int boardHeight = rowCount * tileSize;

    private Image wallImage;
    private Image blueGhost;
    private Image orangeGhost;
    private Image pinkGhost;
    private Image redGhost;
    private Image pacmanUpImage;
    private Image pacmanDownImage;
    private Image pacmanRightImage;
    private Image pacmanLeftImage;
    private Image scaredGhostImage;
    private Image cherryImage1, cherryImage2;
    private Block cherry = null;
    private boolean cherryVisible = false;
    private long cherrySpawnTime = 0;
    private long cherryDuration = 10000; // 10 seconds
    private long cherryInterval = 20000; // Every 20 seconds
    private boolean cherryToggle = false;
    private long lastCherryToggleTime = 0;

    private boolean showPellets = true;
    private long lastPelletToggle = 0;
    private final long pelletBlinkRate = 400;

    // Ghost types: 0=Red, 1=Orange, 2=Pink, 3=Blue
    private HashMap<Block, Integer> ghostTypes = new HashMap<>();


    HashSet<Block> walls;
    HashSet<Block> foods;
    HashSet<Block> ghosts;
    HashSet<Block> powerPellets;

    Block pacman;
    Timer gameLoop;
    char[] directions = {'U', 'D', 'R', 'L'}; // up down right left
    Random random = new Random();
    int score = 0;
    int lives = 3;
    boolean gameOver = false;
    char bufferedDirection = 'R'; // Store the last direction key pressed

    // Scared ghost mechanic
    private boolean ghostsScared = false;
    private long scaredEndTime = 0;
    private final int SCARED_DURATION = 6000; // milliseconds

    // X = wall, O = skip, P = pac man, ' ' = food
    // Ghosts: b = blue, o = orange, p = pink, r = red
    private String[] tileMap = {
            "XXXXXXXXXXXXXXXXXXX",
            "X        X        X",
            "X XX XXX X XXX XX X",
            "X                 X",
            "X XX X XXXXX X XX X",
            "X    X       X    X",
            "XXXX XXXX XXXX XXXX",
            "OOOX X       X XOOO",
            "XXXX X XXrXX X XXXX",
            "O       bpo       O",
            "XXXX X XXXXX X XXXX",
            "OOOX X       X XOOO",
            "XXXX X XXXXX X XXXX",
            "X        X        X",
            "X XX XXX X XXX XX X",
            "X  X     P     X  X",
            "XX X X XXXXX X X XX",
            "X    X   X   X    X",
            "X XXXXXX X XXXXXX X",
            "X                 X",
            "XXXXXXXXXXXXXXXXXXX"
    };

    public Pacman() {
        setPreferredSize(new Dimension(boardWidth, boardHeight));
        setBackground(Color.BLACK);
        addKeyListener(this);
        setFocusable(true);

        // Load images
        wallImage = new ImageIcon(getClass().getResource("/Resources/wall.png")).getImage();
        blueGhost = new ImageIcon(getClass().getResource("/Resources/blueGhost.png")).getImage();
        orangeGhost = new ImageIcon(getClass().getResource("/Resources/orangeGhost.png")).getImage();
        redGhost = new ImageIcon(getClass().getResource("/Resources/redGhost.png")).getImage();
        pinkGhost = new ImageIcon(getClass().getResource("/Resources/pinkGhost.png")).getImage();
        pacmanUpImage = new ImageIcon(getClass().getResource("/Resources/pacmanUp.png")).getImage();
        pacmanRightImage = new ImageIcon(getClass().getResource("/Resources/pacmanRight.png")).getImage();
        pacmanDownImage = new ImageIcon(getClass().getResource("/Resources/pacmanDown.png")).getImage();
        pacmanLeftImage = new ImageIcon(getClass().getResource("/Resources/pacmanLeft.png")).getImage();
        scaredGhostImage = new ImageIcon(getClass().getResource("/Resources/scaredGhost.png")).getImage();
        cherryImage1 = new ImageIcon(getClass().getResource("/Resources/cherry.png")).getImage();
        cherryImage2 = new ImageIcon(getClass().getResource("/Resources/cherry2.png")).getImage();

        loadMap();
        for (Block ghost : ghosts) {
            char newDirection = directions[random.nextInt(4)];
            ghost.updateDirection(newDirection);
        }
        int ghostIndex = 0;
        for (Block ghost : ghosts) ghostTypes.put(ghost, ghostIndex++);
        gameLoop = new Timer(50, this); // 20fps (1000/50)
        gameLoop.start();
    }

    public void loadMap() {
        walls = new HashSet<>();
        foods = new HashSet<>();
        ghosts = new HashSet<>();
        powerPellets = new HashSet<>();

        for (int r = 0; r < rowCount; r++) {
            for (int c = 0; c < columnCount; c++) {
                String row = tileMap[r];
                char tileMapChar = row.charAt(c);

                int x = c * tileSize;
                int y = r * tileSize;

                switch (tileMapChar) {
                    case 'X': // WALLS
                        Block wall = new Block(wallImage, x, y, tileSize, tileSize);
                        walls.add(wall);
                        break;
                    case 'b': // BLUE GHOST
                        ghosts.add(new Block(blueGhost, x, y, tileSize, tileSize));
                        break;
                    case 'r': // RED GHOST
                        ghosts.add(new Block(redGhost, x, y, tileSize, tileSize));
                        break;
                    case 'p': // PINK GHOST
                        ghosts.add(new Block(pinkGhost, x, y, tileSize, tileSize));
                        break;
                    case 'o': // ORANGE GHOST
                        ghosts.add(new Block(orangeGhost, x, y, tileSize, tileSize));
                        break;
                    case 'P': // PACMAN
                        pacman = new Block(pacmanRightImage, x, y, tileSize, tileSize);
                        break;
                    case ' ': // FOOD
                        Block food = new Block(null, x + 14, y + 14, 4, 4);
                        foods.add(food);
                        break;
                    case 'O': // INSIDE WALLS (SKIP)
                        break;
                }
            }
        }

        // Add power pellets in the 4 corners
        int pelletSize = 12;
        int offset = (tileSize - pelletSize) / 2;
        int[][] pelletPositions = {
                {1, 1},
                {1, columnCount - 2},
                {rowCount - 2, 1},
                {rowCount - 2, columnCount - 2}
        };
        for (int[] pos : pelletPositions) {
            int y = pos[0] * tileSize + offset;
            int x = pos[1] * tileSize + offset;
            powerPellets.add(new Block(null, x, y, pelletSize, pelletSize));
        }
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        draw(g);
    }

    public void draw(Graphics g) {
        // Draw walls
        for (Block wall : walls) {
            g.drawImage(wall.image, wall.x, wall.y, wall.width, wall.height, null);
        }

        // Draw foods
        g.setColor(Color.YELLOW);
        for (Block food : foods) {
            g.fillRect(food.x, food.y, food.width, food.height);
        }

        // Draw power pellets
        g.setColor(Color.WHITE);
        for (Block pellet : powerPellets) {
            g.fillOval(pellet.x, pellet.y, pellet.width, pellet.height);
        }

        // Draw ghosts
        for (Block ghost : ghosts) {
            g.drawImage(ghost.image, ghost.x, ghost.y, ghost.width, ghost.height, null);
        }

        // Draw Pac-Man
        g.drawImage(pacman.image, pacman.x, pacman.y, pacman.width, pacman.height, null);

        // Draw score and lives
        g.setFont(new Font("Arial", Font.PLAIN, 18));
        if (gameOver) {
            g.setColor(Color.RED);
            g.drawString("Game Over: " + score, tileSize / 2, tileSize / 2);
        } else {
            g.setColor(Color.WHITE);
            g.drawString("Lives: " + lives + "  Score: " + score, tileSize / 2, tileSize / 2);
        }
        // Power pellet blinking
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastPelletToggle > pelletBlinkRate) {
            showPellets = !showPellets;
            lastPelletToggle = currentTime;
        }
        if (showPellets) {
            g.setColor(Color.WHITE);
            for (Block pellet : powerPellets) {
                g.fillOval(pellet.x, pellet.y, pellet.width, pellet.height);
            }
        }
        // Cherry drawing
        if (cherryVisible && cherry != null) {
            if (currentTime - lastCherryToggleTime > 300) {
                cherryToggle = !cherryToggle;
                lastCherryToggleTime = currentTime;
            }
            g.drawImage(cherryToggle ? cherryImage1 : cherryImage2, cherry.x, cherry.y, cherry.width, cherry.height, null);
        }
    }

    private void moveGhostTowards(Block ghost, int targetX, int targetY) {
        int ghostTileX = ghost.x / tileSize;
        int ghostTileY = ghost.y / tileSize;

        if (targetX > ghostTileX) {
            ghost.updateDirection('R');
        } else if (targetX < ghostTileX) {
            ghost.updateDirection('L');
        } else if (targetY > ghostTileY) {
            ghost.updateDirection('D');
        } else if (targetY < ghostTileY) {
            ghost.updateDirection('U');
        }
    }

    private Block getGhostByType(int type) {
        for (Block ghost : ghosts) {
            if (ghostTypes.get(ghost) == type) {
                return ghost;
            }
        }
        return null; // Return null if no ghost of the specified type is found
    }

    private boolean isTunnelExit(Block ghost) {
        // Tunnel row is row 9 (indexing from 0), exits at columns 0 and 18
        return (ghost.y == tileSize * 9) && 
               (ghost.x <= tileSize || ghost.x >= (columnCount - 2) * tileSize);
    }

    public void move() {
        // Handle scared ghost timer
        if (ghostsScared && System.currentTimeMillis() > scaredEndTime) {
            unsetGhostsScared();
        }

        // Try to turn in the buffered direction if possible
        if (pacman.direction != bufferedDirection) {
            int tempX = pacman.x;
            int tempY = pacman.y;
            int testVX = 0, testVY = 0;

            if (bufferedDirection == 'U') testVY = -tileSize / 4;
            else if (bufferedDirection == 'D') testVY = tileSize / 4;
            else if (bufferedDirection == 'L') testVX = -tileSize / 4;
            else if (bufferedDirection == 'R') testVX = tileSize / 4;

            pacman.x += testVX;
            pacman.y += testVY;
            boolean canTurn = true;

            for (Block wall : walls) {
                if (collision(pacman, wall)) {
                    canTurn = false;
                    break;
                }
            }

            pacman.x = tempX;
            pacman.y = tempY;

            if (canTurn) {
                pacman.updateDirection(bufferedDirection);
                // Update Pac-Man image based on direction
                if (pacman.direction == 'U') pacman.image = pacmanUpImage;
                else if (pacman.direction == 'D') pacman.image = pacmanDownImage;
                else if (pacman.direction == 'L') pacman.image = pacmanLeftImage;
                else if (pacman.direction == 'R') pacman.image = pacmanRightImage;
            }
        }

        // Pac-Man movement
        pacman.x += pacman.velocityX;
        pacman.y += pacman.velocityY;

        // Warp tunnel for Pac-Man (row 9)
        if (pacman.y == tileSize * 9) {
            if (pacman.x < -pacman.width / 2) {
                pacman.x = boardWidth - pacman.width / 2;
            } else if (pacman.x > boardWidth - pacman.width / 2) {
                pacman.x = -pacman.width / 2;
            }
        }

        // Check wall collisions for Pac-Man
        for (Block wall : walls) {
            if (collision(pacman, wall)) {
                pacman.x -= pacman.velocityX;
                pacman.y -= pacman.velocityY;
                break;
            }
        }

        // Handle cherry timing
        long currentTime = System.currentTimeMillis();
        if (!cherryVisible && currentTime - cherrySpawnTime > cherryInterval) {
            cherryVisible = true;
            cherrySpawnTime = currentTime;
            cherry = new Block(cherryImage1, 9 * tileSize, 15 * tileSize, tileSize, tileSize);
        } else if (cherryVisible && currentTime - cherrySpawnTime > cherryDuration) {
            cherryVisible = false;
            cherry = null;
            cherrySpawnTime = currentTime;
        }

        // Check cherry collision
        if (cherryVisible && cherry != null && collision(pacman, cherry)) {
            score += 100;
            cherryVisible = false;
            cherry = null;
            cherrySpawnTime = currentTime;
        }

        // Updated ghost movement logic inside move() method with advanced AI
        final int normalGhostSpeed = tileSize / 4;
        for (Block ghost : ghosts) {
            int type = ghostTypes.get(ghost);
            int pacTileX = pacman.x / tileSize;
            int pacTileY = pacman.y / tileSize;
            int targetX = pacTileX;
            int targetY = pacTileY;

            switch (type) {
                case 0: break; // Blinky chases Pac-Man
                case 1:
                    double dist = Math.sqrt(Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2));
                    if (dist < 6 * tileSize) {
                        targetX = 0;
                        targetY = rowCount - 1;
                    }
                    Block blinky = getGhostByType(0); // Retrieve Blinky (Red Ghost)
                    break;
                case 2:
                    if (pacman.direction == 'U') targetY -= 4;
                    else if (pacman.direction == 'D') targetY += 4;
                    else if (pacman.direction == 'L') targetX -= 4;
                    else if (pacman.direction == 'R') targetX += 4;
                    break;
                case 3:
                    blinky = getGhostByType(0);
                    int vecX = (pacTileX - blinky.x / tileSize) * 2;
                    int vecY = (pacTileY - blinky.y / tileSize) * 2;
                    targetX = blinky.x / tileSize + vecX;
                    targetY = blinky.y / tileSize + vecY;
                    break;
            }
            moveGhostTowards(ghost, targetX, targetY);

            // Set ghost velocity based on direction
            switch (ghost.direction) {
                case 'L': ghost.velocityX = -normalGhostSpeed; ghost.velocityY = 0; break;
                case 'R': ghost.velocityX = normalGhostSpeed; ghost.velocityY = 0; break;
                case 'U': ghost.velocityX = 0; ghost.velocityY = -normalGhostSpeed; break;
                case 'D': ghost.velocityX = 0; ghost.velocityY = normalGhostSpeed; break;
            }

            // Move ghost
            ghost.x += ghost.velocityX;
            ghost.y += ghost.velocityY;

            boolean inTunnel = (ghost.y == tileSize * 9);
            if (inTunnel) {
                if (ghost.x < -ghost.width / 2) {
                    ghost.x = boardWidth - ghost.width / 2;
                } else if (ghost.x > boardWidth - ghost.width / 2) {
                    ghost.x = -ghost.width / 2;
                }
            }

            // Check wall collisions
            boolean hitWall = false;
            for (Block wall : walls) {
                if (collision(ghost, wall)) {
                    hitWall = true;
                    break;
                }
            }
            if (!inTunnel && (ghost.x <= 0 || ghost.x + ghost.width >= boardWidth)) {
                hitWall = true;
            }
            if (hitWall) {
                ghost.x -= ghost.velocityX;
                ghost.y -= ghost.velocityY;
                char[] possibleDirs = (inTunnel && !isTunnelExit(ghost)) ? new char[]{'L', 'R'} : directions;
                char newDirection = possibleDirs[random.nextInt(possibleDirs.length)];
                ghost.updateDirection(newDirection);
            }

            // Pac-Man collision
            if (collision(ghost, pacman)) {
                if (ghostsScared) {
                    score += 200;
                    ghost.reset();
                    int index = 0;
                    for (Block g : ghosts) {
                        if (g == ghost) break;
                        index++;
                    }
                    switch (index) {
                        case 0: ghost.image = blueGhost; break;
                        case 1: ghost.image = orangeGhost; break;
                        case 2: ghost.image = pinkGhost; break;
                        case 3: ghost.image = redGhost; break;
                        default: ghost.image = blueGhost; break;
                    }
                } else {
                    lives--;
                    if (lives == 0) {
                        gameOver = true;
                        gameLoop.stop();
                        return;
                    }
                    resetPositions();
                }
            }
        }

        // Check food collision
        Block foodEaten = null;
        for (Block food : foods) {
            if (collision(pacman, food)) {
                foodEaten = food;
                score += 10;
            }
        }
        if (foodEaten != null) foods.remove(foodEaten);

        // Check power pellet collision
        Block pelletEaten = null;
        for (Block pellet : powerPellets) {
            if (collision(pacman, pellet)) {
                pelletEaten = pellet;
                score += 50;
                setGhostsScared();
                break;
            }
        }
        if (pelletEaten != null) powerPellets.remove(pelletEaten);

        // Reload map if all foods eaten
        if (foods.isEmpty()) {
            loadMap();
            resetPositions();
        }
        
    }

    private void setGhostsScared() {
        ghostsScared = true;
        scaredEndTime = System.currentTimeMillis() + SCARED_DURATION;
        for (Block ghost : ghosts) {
            ghost.image = scaredGhostImage;
        }
    }

    private void unsetGhostsScared() {
        ghostsScared = false;
        int index = 0;
        for (Block ghost : ghosts) {
            switch (index) {
                case 0:
                    ghost.image = blueGhost;
                    break;
                case 1:
                    ghost.image = orangeGhost;
                    break;
                case 2:
                    ghost.image = pinkGhost;
                    break;
                case 3:
                    ghost.image = redGhost;
                    break;
                default:
                    ghost.image = blueGhost;
                    break;
            }
            index++;
        }
    }

    public boolean collision(Block a, Block b) {
        int aPadding = (a == pacman) ? a.collisionPadding : 0;
        int bPadding = (b == pacman) ? b.collisionPadding : 0;

        return a.x + aPadding < b.x + b.width - bPadding &&
                a.x + a.width - aPadding > b.x + bPadding &&
                a.y + aPadding < b.y + b.height - bPadding &&
                a.y + a.height - aPadding > b.y + bPadding;
    }

    public void resetPositions() {
        pacman.reset();
        pacman.velocityX = 0;
        pacman.velocityY = 0;
        pacman.direction = 'R';
        pacman.image = pacmanRightImage;
        for (Block ghost : ghosts) {
            ghost.reset();
            char newDirection = directions[random.nextInt(4)];
            ghost.updateDirection(newDirection);
        }
        unsetGhostsScared();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (!gameOver) {
            move();
            repaint();
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // Not used
    }

    @Override
    public void keyPressed(KeyEvent e) {
        // Not used
    }

    @Override
    public void keyReleased(KeyEvent e) {
        if (gameOver) {
            loadMap();
            resetPositions();
            lives = 3;
            score = 0;
            gameOver = false;
            gameLoop.start();
            return;
        }

        if (e.getKeyCode() == KeyEvent.VK_UP) {
            bufferedDirection = 'U';
        } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
            bufferedDirection = 'D';
        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            bufferedDirection = 'L';
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            bufferedDirection = 'R';
        }
    }
}

